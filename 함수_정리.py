# -*- coding: utf-8 -*-
"""중간고사 전 함수 정리.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K_joVNiCZFbcrmqdzwxDtzOpizbt6jSD

# 거꾸로 정리하기! 
##7주차부터 시작!

Color Map에 관련해서 나오면 CH06보기 p 50 정도 보면 된다.

#### 채널 분리
"""

#채널을 분리하는건
#1
cv2.split()
#2
temp = img[:, :, 0] #blue채널
#채널을 합치는건
cv2.merge()

#한 채널 값만 없애는 거
img_blue_out[:,:,0] =0


#내가 더떤 부분의 함수에 한색만 채우고 싶을땐
image[s_x:e_x, s_y:e_y] =[255:0;0] #bule만 채울거야!
#0 = black = 존재하지 않음 = 화소가 없다
#255 = white = 존재함 = 화소가 있다.

"""#### 모양 바꾸기"""

#평행선을 유지하는 경우 -> 3점 사용
cv2.wrapAffine()

h,w = image.shape[:2]
#VER 1

#이때 M의 0과 1은 고정 tx만큼 x축으로 이동 ty만큼 y축으로 이동 -이면 x는 왼쪽으로 이동 y는 위로 이동한다
M = np.float32([
                [1,0,tx],
                [0,1,ty]
])
M = np.float32([[1,0,200],[0,1,30]])
dst = cv2.wrapAffine(이미지, M, (width, heidht))

#VER 2
pst1(시작점들) = np.float32([x_1,y_1],[x_2,y_2],[x_3,y_3])
pst2(변한점들) = np.float32([x''_1,y''_1],[x''_2,y''_2],[x''_3,y''_3])
M = np.getAffineTranform(pst1,pst2)
dst = cv2.wrapAffine(이미지, M, (width, heidht))


#평행선을 유지 하지 않는 경우 -> 4점 사용
cv2.wrapPerspective()

pst1(시작점들) = np.float32([x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4])
pst2(변한점들) = np.float32([x''_1,y''_1],[x''_2,y''_2],[x''_3,y''_3],[x''_4,y''_4])
M = np.getPerspectiveTranform(pst1,pst2)
dst = cv2.wrapPerspective(이미지, M, (width, heidht))

#이미지의 크기를 변화하는 경우
cv2.resize(이미지, 바꿀 사이즈(tuple로), x축으로 몇배, y축으로 몇배)

#다 test해보기

"""####Arithmetic 이미지"""

#이미 Saturation
#원래라면 이미지는 numpy서 8bit가 최대이니까 숫자가 이하면 ~로 설정 넘으면 ~으로 설정한다.
#근데 cv2.add, cv2.substract 쓰면 자동으로 해줌 그냥 화소끼리 더하면 안되고,

#이미지 합성!!
cv2.addWeighted() #이건 곱셈으로 진행됨 이거 몇 퍼센트 이런식으로

dst = cv2.addWeighted(img1,0.5,img2, 0.5)
#이미지 가장자리 만드는 것도 하기전엔 blurring이 필요함

image_filtered = cv2.GaussianBlur(image, (3, 3), 0)

#이미지 오버플로우가 발생하지 않게끔 cv2.CV_16S 이렇게 하고 
#이건 x축에서 바라본 가장자리
gradient_x = cv2.Sobel(gray_image, cv2.CV_16S, 1, 0, 3)
#y축에서 바라본 가장자리
gradient_x = cv2.Sobel(gray_image, cv2.CV_16S, 0, 1, 3)

abs_gradient_x = cv2.convertScaleAbs(gradient_x)
abs_gradient_y = cv2.convertScaleAbs(gradient_y)

#2개를 합성
sobel_image = cv2.addWeighted(abs_gradient_x, 0.5, abs_gradient_y, 0.5, 0)

"""####이미지 bitwise"""

cv2.bitwise_and(img1,img2) #== 둘다 255 인경우
cv2.bitwise_or(img1,img2) #== 둘 중 하나 라도 255 인경우
cv2.bitwise_not(img1) #== 값 반전
cv2.bitwise_xor(img1,img2) #== 둘의 값이 다른 경우 

#만약 바탕이 검은색 text가 하얀색과 이미지를 and하면

text부분에 이미지가 씌워지고 배경은 black

#or를 하면
text부분은 white 배경이 이미지

"""#### color space"""

#RGB, CIE L*a*b HSL HSV YCbCr등이 존재

"""#### color maps"""

#내가 원하는 color구간으로 바꾸는건데 이건 grayscale이미지에 적용한다.

cv2.applyColorMap()#함수 사용
#이때 적용되는 알고리즘은 다양함내가 원하는 color구간으로 바꾸는건데 이건 grayscale이미지에 적용한다.

cv2.applyColorMap(이미지, cv2.COLORMAP_HOT)등등으로 매칭가능

#Custom color Map은 만들 수 있는 방법은 2가지가 존재
#1. 내가 (BGR채널 전부)0~255값을 하나하나 다 지정해준다.
#2. 특정 값만 지정(lookup 테이블로 지정)을 해준 뒤 함수를 적용한다.

#2-1
cv2.LUT() 이건 차원이 2개
#이건 값을 하나하나 다 지정하기 위해서 사용하는 lut
  lut = np.zeros((256,3),np.uint8)

  s0, s1 = im_gray.shape
  im_color = np.empty(shape=(s0, s1, 3), dtype=np.uint8)

  for i in range(3):
      im_color[..., i] = cv2.LUT(im_gray, lut[:, i])
  return im_color

#2-2
cv2.applyColorMap() 이건 차원이 3개

  lut = np.zeros((256,1,3),np.uint8)
  lut = np.random.randint(255, size=(256, 1, 3), dtype=np.uint8)

      # Apply color map using cv2.applyColorMap()
  im_color = cv2.applyColorMap(im_gray, lut)
  return im_color

#3
값을 0~1 까지 0.25 순서로 색을 배정을 한다음 그 색들을 균등 분포한후 배정하는게 
값은 (
    (0,(B,G,R)),
    (0.25,(B,G,R)),
    (0.5,(B,G,R)),
    (0.75,(B,G,R)),
    (1.0,(B,G,R))
    )
이렇게 배정하면 된다.

우리에겐 255 * 255 * 255 를 하나씩 일일히 배정하지 않아도 좋다.

이때 사용되는 함수는
numpy.linspace( start, stop, num = 50 , endpoint, retstep=false, dtype=None, axis)
를 사용한다.

그래서 lut를 만들어주는 함수를 사용하는데

def build_lut(cmap):
    """Builds look up table based on 'key colors' using np.linspace()"""

    lut = np.empty(shape=(256, 3), dtype=np.uint8)
    max = 256
    # build lookup table:
    lastval, lastcol = cmap[0]
    for step, col in cmap[1:]:
        val = int(step * max)
        for i in range(3):
            lut[lastval:val, i] = np.linspace(lastcol[i], col[i], val - lastval)

        lastcol = col
        lastval = val

    return lut
이렇게 균둥뷴포를 만들어주고 난후.
2-1과 2-2 처럼 LUT와 applyColorMap()을 사용한다.


각 함수에 저 build_lut를 호출해서 사용하는데
lut = build_lut(cmap)

applyColor ~는 3차원이라 reshape를 통해서 사용한다.
lut2 = np.reshape(lut, (256, 1, 3))


그리고 여담으로 legend image -> 띄 형태로 보고 싶으면 
def build_lut_image(cmap, height):
    """Builds the legend image"""

    lut = build_lut(cmap)
    image = np.repeat(lut[np.newaxis, ...], height, axis=0)

    return image
이걸 사용한다.

사용은 cmap자리에 lut를 넣으면 된다!!

"""

#### 영상의 화소 조절은
#### cv2.add, cv2.suvstract등으로 표현이 가능하고

####영상의 명암대비는 주변 화소들의 배율을 재조정해서 보여주는 것은
1. 명암의 평균을 구한다. -> gray이미지인 경우 : avg = cv2.mean(이미지)[0]

color이미지인 경우 : avg = cv2.mean(roi)[0:3]
2. 더미 영상을 만든다. 원본 이미지와 사이즈와 type이 동일하지만, 0으로 채워진
3.명암 대비는 배율로 결정하는데 배율이 작음 감소 크면 증가이다. -> cv2.scaleAdd(이미지, 배율,더미 영상)  = dst = 이미지 * 배율 + 더미 영상
4.cv2.addWeighted(이미지, 배율1, 더미 영상, 배율2, 다른 영상) = dst = 이미지 * 배율1 + 더미 영상 * 배율2 + 다른영상


 배율 증가할지 감소할지 선택해야한다.

"""

영상 대비 변경은

#1. constrast 감소 -> 어두워짐
cv2.scaleAdd(이미지, 0,5, 더미이미지)
#2, constrast 증가 -> 밝아짐 
cv2.scaleAdd(이미지, 2.0, 더미이미지)
#3. 평균을 이용해서 constrast 감소 -> 전반적으로 흐릿해짐
cv2.addWeighted(이미지, 0.5, 더미 이미지, 0, 평균)
#4. 평균을 이용해서 constrast 증가 -> 전반적으로 밝아짐
cv2.addWeighted(이미지, 2.0, 더미 이미지, 0, -평균)

평균을 사용하면 화질 개선이 가능 여기선 평균/2.0 을 이용함

"""####Color Map

CMY는 순수한 검정을 사용 가능! 섞을 수록 어두워지는 색의 3원칙 사용

RGB는 빛의 3원칙 사용

##5&6주차!
"""

color이미지는 image.ndim을 했을때 3이 나오고, gray이미지는 ndim을 하면 2가 나온다 왜냐면 channeldl 1개라서

image의 타입을 바꾸고 싶을때
image.astype(np.~)를 선택하면 된다.
그렇지만 cv2.imshow를 할때는 항상 up.uint8이어야 한다!!

shape을 변경할때

[
      [
       [1,2,3],
       [4,5,6],
       [7,8,9],
       [10,11,12]
       ],
      [
       [11,12,13],
       [14,15,16],
       [17,18,19],
       [20,21,22]
      ]
]
re = mat.reshape(-1,6,2)
# [[[ 1  2]
#   [ 3  4]
#   [ 5  6]
#   [ 7  8]
#   [ 9 10]
#   [11 12]]

#  [[11 12]
#   [13 14]
#   [15 16]
#   [17 18]
#   [19 20]
#   [21 22]]]
결과
dst = image.reshpae(-1,몇줄,한줄에 들어가는 갯수)라 생각하고 할당하면 된다.