# -*- coding: utf-8 -*-
"""중간고사 전 함수정리 4-5강.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZcDTFvsbpGOB6aODglm8Y_QGNvoroLTJ

##그리기 함수
"""

line을 그리는 함수는
cv2.line(그려지는 이미지, 시작점, 끝점, 색, 굵기, 라인타입은 생략 가능)

사각형 그리는 함수
cv2.rectangle(그려지는 이미지 좌상점 우하점 색 굵기 라인타입)
cv2.rectangle(그려지는 이미지 (좌상 우하 점) 색 굵기 라인타입)

이때 굵기가 -1이면 모양의 경우는 색이 채워진다.

문자열
cv2.putText(이미지, text, (좌하 점 =시작점), 폰트종류, 폰트 크기, 색, 굵기, 라인타입)
여러개를 엮어서 새로운 폰트를 만들고 싶으면 cv2 폰트와 다른 cv2 폰트를 | 연산하면 된다다

원그리기
cv2.circle(이미지, center, 반지름, 색, 굵기, 라인 타입)
여기도 굵기가 -1이면 도형 채우기가 된다.

타원그리기

cv2.ellipse(이미지 (x y중심), (x,y각각의 반지름), 각도 , 시작 각도(3시 방향이 0도 시계 방향), 끝 각도, 색,굵기, 라인타입, )
이걸로 반원을 그릴 수 있음!!!


겹쳐지는 선 그리기
참거짓 결과, 시작점, 끝점=cv2.clipline(imgae, 시작점(x,y), 끝점(x,y))


화살표 그리기
cv2.arrowedLine(이미지 시작점 끝점 색 두께, 라인타입,shift =0, 라인 두께(실수))
cv2.arrowedLIne(image, (10,100),(50,100), red, 3, cv2.LINE_AA, 0, 0.5)

"""##다각형 그리기!!! 꼭 실습해보기!! 유일하게 안해본거

## 중요!! 점들을 만들땐 꼭!!!! np.int32로!!
"""

cv2.polylines(이미지, 점들, isClosed, 색, 두께, 라인 타입, shift)
점들은 어레이로 만든다음
wn
pt= np.array([
              [200,20],
              [250,30],
              [300,20]
              ], np.int32)

pts = 입력받은 점들.reshape((-1,1,2))

cv2.polylines(img, pts, isClosed =True, red, thickness, cv2.LINE_AA,0)
이런식으로!!
근데 -1로 하면 오류남 색채울때

개폐에서 False라 하면 마지막점과 첫점을 이어주지 않음!!

"""##영상파일 읽고 쓰는 방법"""

cv2.imread(이미지 주소,mode)
mode = cv2.IMREAD_GRAYSCALE
      cv2.IMREAD_COLOR
      cv2.IMREAD_ANYDEPTH -> 입력 파일에 정의된 깊이에 따라 16/32비트로 변환, 설정이 없으면 8

"""## np로 사용(numpy)로 사용할 있는 방법


"""

np.random.randint(10,size=5)
는 0~9까지 중 5개 랜덤 숫자를 뽑아내기
범위 지정은
np.random.randint(10,20,size(2,6))
도 가능
이건 10이상 20미만 숫자를 (2*6)의 list 형태로 표현하는것이다.

빈 이미지 만들기

color :
image = np.zeros((height,width,3), np.uint8)
gray :
image = np.zeros((height,width,), np.uint8)

"""# cv2관련!

## array처리 함수

cv2.flip(src, code) 수직 수평 양축으로 뒤집는거 가능  -> 0: x축 1: y축 -1:양축

cv2.repeat(src,ny,nx) -> ny nx 수직방향 수평 방향으로 반복 횟수

cv2. transpose(이미지) 대각선으로 뒤집기?? 전치 행렬 가로가 세로가 되고 세로가 가로가 됨.

##채널 함수

cv2.split(이미지) ->채널별로 분리됨

cv2.merge([r,g,b]) 이렇게 하면 채널이 합쳐짐 이미지 출력할때 우리가 많이 씀

## 사칙 연산

cv2.add(이미지1 이미지2, mask =마스크)이러면 관심영역만 더하기
cv2.substract(이미지1,값)을 빼는거
cv2.addWeighted(이미지1,alpha, 이미지2,beta,gamma)는
결과값이 alpha *이미지1 + beta *이미지2 +gamma이다.

# 정말 정말 중요한 합성할때 mask만드는법은 threshold를 이용함
#그리고 하나 명심해야하는거 내가 원하는 결과 값을 알려면 cv2.threshold뒤에 [1]을해야함 왜냐면 얘는 true false값 다음에 경계값이 나옴

first_mask_step = cv2.threshold(이미지2,min값, max값,cv2.THRESHOLD_값)[1]
masks = cv2.split(first_mask_step)

fg_mask_first= cv2.bitwise_or(masks[0],masks[1])
fg_mask= cv2.bitwise_or(masks[0],bg_mask_first)
bg_mask = cv2.bitwise_not(fg_mask)

bg=cv2.bitwise_and(이미지1, 이미지1, mask = bg_mask)
fg=cv2.bitwise_and(이미지2, 이미지2, mask = fg_mask)

cv2.add(bg, fg)
or 
cv2.bitwise_or(bg,fg)

##원소의 절대값 계산

1. cv2.absdiff(원소1 원소2) 두 값의 차이 를 절대값 씌운거
2. cv2.convertScaleAbs(이미지, dst, alpha,beta)
입력 배열의 원소에 alpha만큼 곱하고 beta만큼 더해서 절대값을 8bit 자료형으로 변환

##원소의 min max찾기

cv2.min(이미지1,이미지2) 두 이미지 비교해서 작은 값 배열 출력

cv2.max(이미지1,이미지2) 두 이미지 비교해서 큰 값 배열 출력

min,max, min의 위치, max의 위치 =cv2.minMaxLoc(이미지1) 
그냥 값만 알고 싶음
min, max,_,_ = cv2.minMaxLoc(이미지)하면 된다.

그리고 영상을 보정할땐 
비율을 신경써서 하는데 이땐 어떻게 하느냐

###비율 = 255/(max -min)
### 결과 이미지 - np.round(이미지 - min) *비율).astype(np.uint8)
로 하면 된다
"""



#
